var search_data = {"index":{"searchIndex":["andnode","andthen","applynode","arraylistnode","bikeclass","bikemethod","bikeobject","callnode","classnode","context","datanode","defnode","elseifnode","falsenode","fornode","getconstantnode","getlocalnode","hashnode","ifnode","importnode","interpreter","lambdanode","lexer","literalnode","nilnode","nodes","numbernode","object","ornode","packagenode","parser","setclassnode","setlocalarynode","setlocaldescnode","setlocalnode","string","stringnode","truenode","typealiasnode","unlessnode","whilenode","<<()","_reduce_none()","apply()","call()","call()","call_method()","check_all_arguments()","def()","define_and()","define_is()","define_isnt()","define_or()","eval()","eval()","eval()","eval()","eval()","eval()","eval()","eval()","eval()","eval()","eval()","eval()","eval()","eval()","eval()","eval()","eval()","eval()","eval()","eval()","eval()","eval()","eval()","eval()","eval()","eval()","eval()","eval()","eval()","eval()","lookup()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new_with_value()","to_a()","to_fi()","tokenize()","valid_braces?()","valid_code?()","valid_curlies?()","valid_parentheses?()"],"longSearchIndex":["andnode","andthen","applynode","arraylistnode","bikeclass","bikemethod","bikeobject","callnode","classnode","context","datanode","defnode","elseifnode","falsenode","fornode","getconstantnode","getlocalnode","hashnode","ifnode","importnode","interpreter","lambdanode","lexer","literalnode","nilnode","nodes","numbernode","object","ornode","packagenode","parser","setclassnode","setlocalarynode","setlocaldescnode","setlocalnode","string","stringnode","truenode","typealiasnode","unlessnode","whilenode","nodes#<<()","parser#_reduce_none()","bikeobject#apply()","bikemethod#call()","bikeobject#call()","bikemethod#call_method()","object#check_all_arguments()","bikeclass#def()","object#define_and()","object#define_is()","object#define_isnt()","object#define_or()","andnode#eval()","applynode#eval()","arraylistnode#eval()","callnode#eval()","classnode#eval()","datanode#eval()","defnode#eval()","falsenode#eval()","fornode#eval()","getconstantnode#eval()","getlocalnode#eval()","hashnode#eval()","ifnode#eval()","importnode#eval()","interpreter#eval()","lambdanode#eval()","nilnode#eval()","nodes#eval()","numbernode#eval()","ornode#eval()","packagenode#eval()","setclassnode#eval()","setlocalarynode#eval()","setlocaldescnode#eval()","setlocalnode#eval()","stringnode#eval()","truenode#eval()","typealiasnode#eval()","unlessnode#eval()","whilenode#eval()","bikeclass#lookup()","bikeclass::new()","bikeclass#new()","bikemethod::new()","bikeobject::new()","context::new()","falsenode::new()","interpreter::new()","nilnode::new()","truenode::new()","bikeclass#new_with_value()","object#to_a()","object#to_fi()","lexer#tokenize()","string#valid_braces?()","string#valid_code?()","string#valid_curlies?()","string#valid_parentheses?()"],"info":[["AndNode","","AndNode.html","","<p>Boolean AND\n"],["AndThen","","AndThen.html","",""],["ApplyNode","","ApplyNode.html","","<p>Used for all applying of functions\n"],["ArrayListNode","","ArrayListNode.html","","<p>Wraps a ruby array, and then wraps all of the arrays elements\n"],["BikeClass","","BikeClass.html","","<p>Classes are objects in Bike so they inherit from BikeObject. BikeClass is\nthe way of representing Bike …\n"],["BikeMethod","","BikeMethod.html","","<p>BikeMethod represents a method (also a function and lambda) in Bike.\nExample of usage:\n\n<pre>BikeMethod.new([&#39;a&#39;, ...</pre>\n"],["BikeObject","","BikeObject.html","","<p>BikeObject represeints the bare skeleton of what an object should have in\nthe Bike runtime. It also provides …\n"],["CallNode","","CallNode.html","","<p>The CallNode for calling a method is a little more complex. It needs to set\nthe <code>receiver</code> first and then …\n"],["ClassNode","","ClassNode.html","","<p>Defining a class is done in three steps:\n<p>Reopen or define the class.\n<p>Create a special context of evaluation …\n"],["Context","","Context.html","","<p>Context works to provide lexical scoping and a concept of <code>self</code>\nto functions and classes.\n"],["DataNode","","DataNode.html","","<p>An enumeration + an algebraic datatype\n"],["DefNode","","DefNode.html","","<p>Node for defining a named function\n<p>Each method definition will be stored into the following node. It holds …\n"],["ElseIfNode","","ElseIfNode.html","",""],["FalseNode","","FalseNode.html","","<p>Wraps ruby `false`\n"],["ForNode","","ForNode.html","","<p>A python-esque for loop\n"],["GetConstantNode","","GetConstantNode.html","","<p>Returns the constant with the corresponding name. A constant is a class.\n<p>Retrieving the value of a constant …\n"],["GetLocalNode","","GetLocalNode.html","","<p>Gets value of variable\n<p>Similar to the previous nodes, the next ones are for dealing with local\nvariables. …\n"],["HashNode","","HashNode.html","","<p>A hash is an anonymous class with syntactic sugar.\n"],["IfNode","","IfNode.html","","<p>Finally, to implement if in our language, we turn the condition node into a\nRuby value to use Ruby&#39;s …\n"],["ImportNode","","ImportNode.html","","<p>Imports the named file into a variable, or into a variable with the file\nname.\n"],["Interpreter","","Interpreter.html","","<p>First, we create an simple wrapper class to encapsulate the interpretation\nprocess. All this does is …\n"],["LambdaNode","","LambdaNode.html","","<p>Lambda: anonymous function\n"],["Lexer","","Lexer.html","",""],["LiteralNode","","LiteralNode.html","","<p>Literals are static values that have a Ruby representation. For example, a\nstring, a number, true, false, …\n"],["NilNode","","NilNode.html","","<p>Wraps ruby `nil`\n"],["Nodes","","Nodes.html","","<p>The Nodes class will always be at the top of the AST. Its only purpose it\nto contain other nodes. It …\n"],["NumberNode","","NumberNode.html","","<p>We&#39;re using Constants that we created before when bootstrapping the\nruntime to access the objects …\n"],["Object","","Object.html","",""],["OrNode","","OrNode.html","","<p>Boolean OR\n"],["PackageNode","","PackageNode.html","","<p>An anonymous class that corrosponds to a file\n"],["Parser","","Parser.html","",""],["SetClassNode","","SetClassNode.html","","<p>Sets a class into the scope\n"],["SetLocalAryNode","","SetLocalAryNode.html","","<p>Array destructuring.\n"],["SetLocalDescNode","","SetLocalDescNode.html","","<p>Sets a destructuring local variables.\n"],["SetLocalNode","","SetLocalNode.html","","<p>Sets a variable local to the scope.\n"],["String","","String.html","",""],["StringNode","","StringNode.html","","<p>Returns a Bike-compatable String class that wraps a ruby string.\n"],["TrueNode","","TrueNode.html","","<p>Wraps ruby `true`\n"],["TypeAliasNode","","TypeAliasNode.html","","<p>Alias a type\n"],["UnlessNode","","UnlessNode.html","","<p>Unless == if not expression\n"],["WhileNode","","WhileNode.html","","<p>A While loop\n"],["<<","Nodes","Nodes.html#method-i-3C-3C","(node)",""],["_reduce_none","Parser","Parser.html#method-i-_reduce_none","(val, _values, result)",""],["apply","BikeObject","BikeObject.html#method-i-apply","(context, method, arguments=[])","<p>Calls a method that has been stored as a variable (like calling a lambda\nthat was passed into a function.) …\n"],["call","BikeMethod","BikeMethod.html#method-i-call","(receiver, arguments)","<p>The <code>call</code> method takes the reciever (normally the global\ninstance of Object, unless the function is called …\n"],["call","BikeObject","BikeObject.html#method-i-call","(method, arguments=[], context)","<p>Calls a runtime method.\n"],["call_method","BikeMethod","BikeMethod.html#method-i-call_method","(receiver, arguments)",""],["check_all_arguments","Object","Object.html#method-i-check_all_arguments","(args)",""],["def","BikeClass","BikeClass.html#method-i-def","(name, &block)","<p>Helper method to define a method on this class from Ruby. <strong>Only use\nthis in bootstrap.rb to keep the code</strong> …\n"],["define_and","Object","Object.html#method-i-define_and","(type)",""],["define_is","Object","Object.html#method-i-define_is","(type)",""],["define_isnt","Object","Object.html#method-i-define_isnt","(type)",""],["define_or","Object","Object.html#method-i-define_or","(type)",""],["eval","AndNode","AndNode.html#method-i-eval","(context)",""],["eval","ApplyNode","ApplyNode.html#method-i-eval","(context)",""],["eval","ArrayListNode","ArrayListNode.html#method-i-eval","(context)",""],["eval","CallNode","CallNode.html#method-i-eval","(context)",""],["eval","ClassNode","ClassNode.html#method-i-eval","(context)",""],["eval","DataNode","DataNode.html#method-i-eval","(context)",""],["eval","DefNode","DefNode.html#method-i-eval","(context)",""],["eval","FalseNode","FalseNode.html#method-i-eval","(_)",""],["eval","ForNode","ForNode.html#method-i-eval","(context)",""],["eval","GetConstantNode","GetConstantNode.html#method-i-eval","(_)",""],["eval","GetLocalNode","GetLocalNode.html#method-i-eval","(context)",""],["eval","HashNode","HashNode.html#method-i-eval","(_)",""],["eval","IfNode","IfNode.html#method-i-eval","(context)",""],["eval","ImportNode","ImportNode.html#method-i-eval","(context)",""],["eval","Interpreter","Interpreter.html#method-i-eval","(code)",""],["eval","LambdaNode","LambdaNode.html#method-i-eval","(context)",""],["eval","NilNode","NilNode.html#method-i-eval","(_)",""],["eval","Nodes","Nodes.html#method-i-eval","(context)",""],["eval","NumberNode","NumberNode.html#method-i-eval","(_)",""],["eval","OrNode","OrNode.html#method-i-eval","(context)",""],["eval","PackageNode","PackageNode.html#method-i-eval","(context)",""],["eval","SetClassNode","SetClassNode.html#method-i-eval","(context)",""],["eval","SetLocalAryNode","SetLocalAryNode.html#method-i-eval","(context)",""],["eval","SetLocalDescNode","SetLocalDescNode.html#method-i-eval","(context)",""],["eval","SetLocalNode","SetLocalNode.html#method-i-eval","(context)",""],["eval","StringNode","StringNode.html#method-i-eval","(_)",""],["eval","TrueNode","TrueNode.html#method-i-eval","(_)",""],["eval","TypeAliasNode","TypeAliasNode.html#method-i-eval","(_)",""],["eval","UnlessNode","UnlessNode.html#method-i-eval","(context)",""],["eval","WhileNode","WhileNode.html#method-i-eval","(context)",""],["lookup","BikeClass","BikeClass.html#method-i-lookup","(method_name)","<p>Lookup a method and return it. Looks through all of the\n<code>runtime_methods</code> all the way up the superclass …\n"],["new","BikeClass","BikeClass.html#method-c-new","(superclass = 'Object', type = 'Dynamic', _ = [], name = 'Object')","<p>The initialization is basicly getting the superclass from constants,\ncopying all of the methods from …\n"],["new","BikeClass","BikeClass.html#method-i-new","()","<p>Create a new instance of this class\n"],["new","BikeMethod","BikeMethod.html#method-c-new","(params, body, context = 'Object', name = '', type_ret = 'Dynamic')","<p>This method just sets the corresponding arguments onto properties of the\nsame name and returns the new …\n"],["new","BikeObject","BikeObject.html#method-c-new","(runtime_class, ruby_value = 'Object', type = runtime_class.ruby_value, name = nil)",""],["new","Context","Context.html#method-c-new","(current_self, current_class = current_self.runtime_class)",""],["new","FalseNode","FalseNode.html#method-c-new","()",""],["new","Interpreter","Interpreter.html#method-c-new","()",""],["new","NilNode","NilNode.html#method-c-new","()",""],["new","TrueNode","TrueNode.html#method-c-new","()",""],["new_with_value","BikeClass","BikeClass.html#method-i-new_with_value","(value, type = nil)","<p>Create an instance of this Bike class that holds a Ruby value. Like a Str,\nNumber or true.\n"],["to_a","Object","Object.html#method-i-to_a","()",""],["to_fi","Object","Object.html#method-i-to_fi","(v)",""],["tokenize","Lexer","Lexer.html#method-i-tokenize","(code)",""],["valid_braces?","String","String.html#method-i-valid_braces-3F","()",""],["valid_code?","String","String.html#method-i-valid_code-3F","()",""],["valid_curlies?","String","String.html#method-i-valid_curlies-3F","()",""],["valid_parentheses?","String","String.html#method-i-valid_parentheses-3F","()",""]]}}