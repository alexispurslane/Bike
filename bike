#!/usr/bin/env ruby -I.
require_relative "interpreter"
require "readline"
require 'colorize'
require 'terminfo'

width = TermInfo.screen_size[1]

interpreter = Interpreter.new
lexer = false
parser = false

trap('INT', 'SIG_IGN')
LIST = [
  'import', 'class', 'Wheels',
  'wheels', ':exit', ':history',
  ':help', ':lexer', ':clear',
  'let', 'var', 'def', 'lambda',
  'with', 'apply', 'while', 'else',
  'unless', 'if', 'println', 'print',
  'package', 'with', 'mixin', 'reopen',
  '...', ':parser', 'hash'
].sort

comp = proc { |s| LIST.grep( /^#{Regexp.escape(s)}/ ) }

Readline.completion_append_character = " "
Readline.completion_proc = comp

# If a file is given we eval it.
if file = ARGV.first
  interpreter.eval File.read(file)

  # Start the REPL, read-eval-print-loop, or interactive interpreter
else
  n = 1
  puts "Bike Programming Language REPL".colorize(:light_black).on_white.center(width) +
       "              (Type :help for help, and :exit to exit)".center(width) +
       "              (See LICENSE.md for licensing information)".center(width)
  puts "By Christopher Dumas in 2014".green.center(width)
  loop do
    line = Readline::readline("[#{n}] >> ".blue)    # 1. Read
    Readline::HISTORY.push(line)
    n += 1
    line = line.strip
    if line == ":exit"
      puts "Bye!".blue
      exit
    elsif line == ":help"
      puts <<-eos
      :help        - This help
      :exit        - To exit from the REPL
      :lexer       - To have your input lexed only, but not interpreted
      :lexer       - To have your input parsed only, but not interpreted
      :history     - List history
      :clear       - Clear Screen
      eos
    elsif line == ":history"
      puts "HISTORY".yellow
      puts "-------".yellow
      Readline::HISTORY.to_a.each { |e| puts e }
    elsif line == ":clear"
      system "clear" or system "cls"
      puts "Bike Programming Language REPL".colorize(:light_black).on_white.center(width)
    elsif line == ":lexer"
      lexer = !lexer
      if lexer
        puts "Entering Lexer mode. To go back to normal mode, type :lexer again.".red
      else
        puts "Leaving Lexer mode now.".blue
      end
    elsif line == ":parser"
      parser = !parser
      if parser
        puts "Entering Parser mode. To go back to normal mode, type :parser again.".red
      else
        puts "Leaving Parser mode now.".blue
      end
    else
      if lexer
        value = Lexer.new.tokenize(line)
        puts "#{value.inspect}"     # 3. Print
      elsif parser
        value = Parser.new.parse(line)
        puts "#{value.inspect}"     # 3. Print
      else
#       begin
          value = interpreter.eval(line) # 4. Eval
#       rescue => e
#         puts "[ERROR]: ".red.gsub("\n", '') + e.message.yellow.gsub(/\(.*\)/, '').gsub("\n", '')
#         value = interpreter.eval('nil')
#       end

        if value.ruby_value.is_a?(Array)
          print "<= [".light_white
          print value.ruby_value.map { |i| i.ruby_value.inspect }.join(", ").light_white
          puts "]".light_white
        else
          puts "<= #{value.ruby_value.inspect}".light_white   # 3. Print
        end
      end
    end                                      # 4. Loop
  end 
end
